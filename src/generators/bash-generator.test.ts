import { describe, it, expect, vi, beforeEach } from 'vitest'
import { generateBashStatusline } from './bash-generator.js'
import { 
  minimalConfig, 
  detailedConfig, 
  compactConfig, 
  systemMonitoringConfig,
  allFeaturesConfig 
} from '../__tests__/fixtures/mock-configs.js'
import { testUtils } from '../__tests__/setup.js'

// Mock the cache manager to avoid file system operations in tests
vi.mock('../utils/cache-manager.js', () => ({
  cacheManager: {
    generateCacheKey: vi.fn(() => 'test-cache-key'),
    getFromMemory: vi.fn(() => null),
    setInMemory: vi.fn(),
    updateMetrics: vi.fn(),
    generateCacheInitCode: vi.fn(() => '# cache init code'),
    generateProcessCacheCode: vi.fn(() => '# process cache code'),
    generateFileCacheCode: vi.fn(() => '# file cache code'),
  },
  generateFeatureHash: vi.fn(() => 'test-hash'),
  generateContextHash: vi.fn(() => 'test-context-hash'),
}))

// Mock the template cache to force using the main generator
vi.mock('./template-cache.js', () => ({
  generateOptimizedBashStatusline: vi.fn(() => null),
}))

describe('generateBashStatusline', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should generate a basic bash script for minimal config', () => {
    const result = generateBashStatusline(minimalConfig)
    
    expect(result).toContain('#!/bin/bash')
    expect(result).toContain('Generated by cc-statusline')
    expect(result).toContain('input=$(cat)')
    expect(result).toContain('# ---- color helpers')
    expect(result).toContain('# ---- basics ----')
  })

  it('should include git features when enabled', () => {
    const result = generateBashStatusline(minimalConfig)
    
    expect(result).toContain('# ---- git ----')
    expect(result).toContain('git_branch=')
    expect(result).toContain('git symbolic-ref --short HEAD')
    expect(result).toContain('ðŸŒ¿') // git emoji for minimal config with colors
  })

  it('should include directory feature when enabled', () => {
    const result = generateBashStatusline(minimalConfig)
    
    expect(result).toContain('cwd=')
    expect(result).toContain('current_dir')
    expect(result).toContain('ðŸ“') // directory emoji
  })

  it('should generate comprehensive script for detailed config', () => {
    const result = generateBashStatusline(detailedConfig)
    
    expect(result).toContain('#!/bin/bash')
    expect(result).toContain('Theme: detailed')
    expect(result).toContain('Colors: true')
    expect(result).toContain('Features: directory, git, model, usage, session, cache, context')
    
    // Should include usage features  
    expect(result).toContain('costUSD')
    expect(result).toContain('burnRate')
    expect(result).toContain('tot_tokens')
    
    // Should include logging when enabled
    expect(result).toContain('LOG_FILE=')
    expect(result).toContain('statusline.log')
  })

  it('should disable colors for compact config when colors=false', () => {
    const result = generateBashStatusline(compactConfig)
    
    expect(result).toContain('use_color=0')
    expect(result).toContain('C() { :; }')
    expect(result).toContain('RST() { :; }')
  })

  it('should include system monitoring features', () => {
    const result = generateBashStatusline(systemMonitoringConfig)
    
    expect(result).toContain('# ---- system monitoring ----')
    expect(result).toContain('cpu')
    expect(result).toContain('memory')
    expect(result).toContain('load')
  })

  it('should handle all features configuration', () => {
    const result = generateBashStatusline(allFeaturesConfig)
    
    // Check for all major feature sections
    expect(result).toContain('# ---- git ----')
    expect(result).toContain('# ---- ccusage integration ----')
    expect(result).toContain('# ---- system monitoring ----')
    expect(result).toContain('# ---- render statusline ----')
    
    // Check for usage features
    expect(result).toContain('burnRate')
    expect(result).toContain('projection')
    expect(result).toContain('cache_creation_tokens')
    
    // Check for logging
    expect(result).toContain('LOG_FILE=')
  })

  it('should generate different scripts for different themes', () => {
    const minimal = generateBashStatusline({ ...minimalConfig, theme: 'minimal' })
    const detailed = generateBashStatusline({ ...minimalConfig, theme: 'detailed' })
    const compact = generateBashStatusline({ ...minimalConfig, theme: 'compact' })
    
    expect(minimal).toContain('Theme: minimal')
    expect(detailed).toContain('Theme: detailed')
    expect(compact).toContain('Theme: compact')
    
    // Scripts should be different
    expect(minimal).not.toBe(detailed)
    expect(detailed).not.toBe(compact)
  })

  it('should include custom emojis setting in header', () => {
    const configWithCustomEmojis = { ...minimalConfig, customEmojis: true }
    const result = generateBashStatusline(configWithCustomEmojis)
    
    expect(result).toContain('Colors: true')
    expect(result).toContain('Features: directory, git')
  })

  it('should include ccusage integration when enabled', () => {
    const result = generateBashStatusline(detailedConfig)
    
    expect(result).toContain('ccusage')
    expect(result).toContain('costUSD')
    expect(result).toContain('burnRate')
  })

  it('should generate valid bash syntax', () => {
    const result = generateBashStatusline(allFeaturesConfig)
    
    // Check for proper bash syntax elements
    expect(result).toContain('#!/bin/bash')
    expect(result).toMatch(/if.*then/s)
    expect(result).toMatch(/printf.*%s/s)
    expect(result).toContain('fi')
    
    // Should not have obvious syntax errors
    expect(result).not.toContain('if;')
    expect(result).not.toContain('then;')
    // Note: ;; is valid in case statements, so we don't check for it
  })

  it('should handle runtime selection', () => {
    const bashConfig = { ...minimalConfig, runtime: 'bash' as const }
    const result = generateBashStatusline(bashConfig)
    
    expect(result).toContain('#!/bin/bash')
  })

  it('should include proper feature ordering in display section', () => {
    const result = generateBashStatusline(allFeaturesConfig)
    
    // Check that render section exists
    expect(result).toContain('# ---- render statusline ----')
    
    // Should include printf statements for directory, git, model, etc.
    expect(result).toContain('printf')
  })

  it('should be deterministic for same config', () => {
    const result1 = generateBashStatusline(minimalConfig)
    const result2 = generateBashStatusline(minimalConfig)
    
    // Results should be identical (excluding timestamp in header)
    const normalize = (script: string) => testUtils.normalizeString(script.replace(/Created: .*/, 'Created: [timestamp]'))
    expect(normalize(result1)).toBe(normalize(result2))
  })

  it('should generate non-empty script for any valid config', () => {
    const configs = [minimalConfig, detailedConfig, compactConfig, systemMonitoringConfig]
    
    configs.forEach(config => {
      const result = generateBashStatusline(config)
      expect(result.length).toBeGreaterThan(100)
      expect(result).toContain('#!/bin/bash')
    })
  })

  it('should include feature utilities when features are enabled', () => {
    const gitConfig = { ...minimalConfig, features: ['git'] }
    const result = generateBashStatusline(gitConfig)
    
    expect(result).toContain('num_or_zero')
  })

  it('should optimize the generated script', () => {
    const result = generateBashStatusline(allFeaturesConfig)
    
    // The result should be optimized (no excessive whitespace)
    expect(result).not.toContain('\n\n\n\n')
    expect(result).not.toMatch(/^\s+$/m) // No lines with only whitespace
  })

  describe('Content Tracking and Rate Limiting Integration', () => {
    it('should include rate limiting helper functions', () => {
      const result = generateBashStatusline(minimalConfig)
      
      expect(result).toContain('# ---- rate limiting and error recovery ----')
      expect(result).toContain('rate_limit_file=')
      expect(result).toContain('min_interval=')
    })

    it('should include content tracking helper functions', () => {
      const result = generateBashStatusline(minimalConfig)
      
      expect(result).toContain('# ---- content tracking and terminal safety ----')
      expect(result).toContain('content_displayed=0')
    })

    it('should set content tracking flags in display sections', () => {
      const result = generateBashStatusline(detailedConfig)
      
      // Directory should set content_displayed
      expect(result).toMatch(/printf.*ðŸ“.*\n.*content_displayed=1/s)
      
      // Model should set content_displayed  
      expect(result).toMatch(/printf.*ðŸ¤–.*\n.*content_displayed=1/s)
    })

    it('should have conditional newline based on content_displayed', () => {
      const result = generateBashStatusline(allFeaturesConfig)
      
      expect(result).toContain('if [[ $content_displayed -eq 1 ]]')
      expect(result).toContain('printf \'\\n\'')
      expect(result).toContain('fi')
    })

    it('should not have unconditional newlines for compact mode', () => {
      const compactConfig = { ...allFeaturesConfig, theme: 'compact' as const }
      const result = generateBashStatusline(compactConfig)
      
      // Should have conditional newline only
      expect(result).toContain('if [[ $content_displayed -eq 1 ]]')
      
      // Should have exactly one printf '\n' (the conditional one)
      const newlinePrintfMatches = result.match(/printf\s+'\\n'/g)
      expect(newlinePrintfMatches).toHaveLength(1)
    })
  })
})