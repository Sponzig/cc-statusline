import { StatuslineConfig } from '../cli/prompts.js'
import { generateColorBashCode, generateBasicColors } from '../features/colors.js'
import { generateGitBashCode, generateGitDisplayCode, generateGitUtilities } from '../features/git.js'
import { generateUsageBashCode, generateUsageDisplayCode, generateUsageUtilities } from '../features/usage.js'
import { cacheManager, generateFeatureHash } from '../utils/cache-manager.js'

export function generateBashStatusline(config: StatuslineConfig): string {
  const startTime = Date.now()
  
  // Template-level caching - check if we've generated this exact configuration before
  const templateHash = generateFeatureHash(config.features, {
    colors: config.colors,
    theme: config.theme,
    ccusageIntegration: config.ccusageIntegration,
    customEmojis: config.customEmojis,
    logging: config.logging
  })
  const templateCacheKey = cacheManager.generateCacheKey('template', templateHash)
  
  // Check memory cache for complete script
  const cachedScript = cacheManager.getFromMemory<string>(templateCacheKey)
  if (cachedScript) {
    return cachedScript
  }

  // Pre-compute feature flags for better performance
  const features = new Set(config.features)
  const hasGit = features.has('git')
  const hasUsage = features.has('usage') || features.has('session') || features.has('tokens') || features.has('burnrate')
  const hasDirectory = features.has('directory')
  const hasModel = features.has('model')

  // Build feature configs once
  const usageConfig = {
    enabled: hasUsage && config.ccusageIntegration,
    showCost: features.has('usage'),
    showTokens: features.has('tokens'),
    showBurnRate: features.has('burnrate'),
    showSession: features.has('session'),
    showProgressBar: config.theme !== 'minimal' && features.has('session')
  }

  const gitConfig = {
    enabled: hasGit,
    showBranch: hasGit,
    showChanges: false,
    compactMode: config.theme === 'compact'
  }

  // Use array for better performance than string concatenation
  const parts: string[] = [
    generateScriptHeader(config),
    config.logging ? generateLoggingCode() : '',
    'input=$(cat)',
    generateColorBashCode({ enabled: config.colors, theme: config.theme }),
    config.colors ? generateBasicColors() : '',
    hasUsage ? generateUsageUtilities() : '',
    hasGit ? generateGitUtilities() : '',
    generateBasicDataExtraction(hasDirectory, hasModel),
    hasGit ? generateGitBashCode(gitConfig, config.colors) : '',
    hasUsage ? generateUsageBashCode(usageConfig, config.colors) : '',
    config.logging ? generateLoggingOutput() : '',
    generateDisplaySection(config, gitConfig, usageConfig)
  ]

  // Filter empty parts and join efficiently
  const generatedScript = parts.filter(Boolean).join('\n') + '\n'
  
  // Cache the generated script and update performance metrics
  const generationTime = Date.now() - startTime
  cacheManager.setInMemory(templateCacheKey, generatedScript, 'template', templateHash)
  cacheManager.updateMetrics({
    scriptSize: generatedScript.length,
    generationTime,
    featureComplexity: config.features.length
  })
  
  return generatedScript
}

function generateScriptHeader(config: StatuslineConfig): string {
  const timestamp = new Date().toISOString()
  return `#!/bin/bash
# Generated by cc-statusline (https://www.npmjs.com/package/@chongdashu/cc-statusline)
# Custom Claude Code statusline - Created: ${timestamp}
# Theme: ${config.theme} | Colors: ${config.colors} | Features: ${config.features.join(', ')}`
}

function generateLoggingCode(): string {
  return `
LOG_FILE="\${HOME}/.claude/statusline.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# ---- logging ----
{
  echo "[$TIMESTAMP] Status line triggered with input:"
  (echo "$input" | jq . 2>/dev/null) || echo "$input"
  echo "---"
} >> "$LOG_FILE" 2>/dev/null
`
}

function generateBasicDataExtraction(hasDirectory: boolean, hasModel: boolean): string {
  // Optimize JSON parsing with single jq call when possible
  if (!hasDirectory && !hasModel) return ''
  
  const jqFields: string[] = []
  const fallbackVars: string[] = []
  
  if (hasDirectory) {
    jqFields.push('current_dir: (.workspace.current_dir // .cwd // "unknown")')
    fallbackVars.push('current_dir="unknown"')
  }
  
  if (hasModel) {
    jqFields.push('model_name: (.model.display_name // "Claude")')
    jqFields.push('model_version: (.model.version // "")')
    fallbackVars.push('model_name="Claude"; model_version=""')
  }

  const jqQuery = `{${jqFields.join(', ')}}`
  
  return `
# ---- basics ----
if command -v jq >/dev/null 2>&1; then
  eval "$(echo "$input" | jq -r '${jqQuery} | to_entries | .[] | "\\(.key)=\\(.value | @sh)"' 2>/dev/null)"${hasDirectory ? `
  current_dir=$(echo "$current_dir" | sed "s|^$HOME|~|g")` : ''}
else
  ${fallbackVars.join('; ')}
fi
`
}

function generateLoggingOutput(): string {
  return `
# ---- log extracted data ----
{
  echo "[\$TIMESTAMP] Extracted: dir=\${current_dir:-}, model=\${model_name:-}, version=\${model_version:-}, git=\${git_branch:-}, cost=\${cost_usd:-}, cost_ph=\${cost_per_hour:-}, tokens=\${tot_tokens:-}, tpm=\${tpm:-}, session_pct=\${session_pct:-}"
} >> "$LOG_FILE" 2>/dev/null
`
}

function generateDisplaySection(config: StatuslineConfig, gitConfig: any, usageConfig: any): string {
  const emojis = config.colors && !config.customEmojis
  const features = new Set(config.features)

  // Logical feature ordering (grouped by context)
  const featurePriority = [
    'directory',  // 1. Where am I?
    'git',        // 2. What branch/commit?
    'model',      // 3. What model am I using?
    'usage',      // 4. Usage & cost info
    'session',
    'tokens', 
    'burnrate'
  ]

  let displayCode = `
# ---- render statusline ----`

  // Render features in priority order
  for (const feature of featurePriority) {
    if (!features.has(feature)) continue

    switch (feature) {
      case 'directory':
        const dirEmoji = emojis ? 'üìÅ' : 'dir:'
        const dirColorPrefix = config.colors ? '$(dir_color)' : ''
        const dirColorSuffix = config.colors ? '$(rst)' : ''
        displayCode += `
printf '${dirEmoji} %s%s%s' "${dirColorPrefix}" "$current_dir" "${dirColorSuffix}"`
        break

      case 'model':
        const modelEmoji = emojis ? 'ü§ñ' : 'model:'
        const modelColorPrefix = config.colors ? '$(model_color)' : ''
        const modelColorSuffix = config.colors ? '$(rst)' : ''
        displayCode += `
printf '  ${modelEmoji} %s%s%s' "${modelColorPrefix}" "$model_name" "${modelColorSuffix}"`
        break

      case 'git':
        displayCode += generateGitDisplayCode(gitConfig, config.colors, emojis)
        break

      case 'usage':
      case 'session':
      case 'tokens':
      case 'burnrate':
        // Only add usage display once
        if (feature === 'usage' || (!features.has('usage') && feature === 'session')) {
          displayCode += generateUsageDisplayCode(usageConfig, config.colors, emojis)
        }
        break
    }
  }

  return displayCode
}