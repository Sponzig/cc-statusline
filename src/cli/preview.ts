import { StatuslineConfig } from './prompts.js'
import { generateBashStatusline } from '../generators/bash-generator.js'
import { testStatuslineScript, generateMockClaudeInput, analyzeTestResult } from '../utils/tester.js'
import { promises as fs } from 'fs'
import chalk from 'chalk'
import ora from 'ora'

export async function previewCommand(scriptPath: string): Promise<void> {
  console.log(chalk.cyan('üîç Statusline Preview Mode\n'))
  
  let script: string
  
  // Load existing statusline script
  try {
    const spinner = ora(`Loading statusline script from ${scriptPath}...`).start()
    script = await fs.readFile(scriptPath, 'utf-8')
    spinner.succeed('Script loaded!')
    
    // Try to extract config info from the script header
    const headerMatch = script.match(/# Theme: (\w+) \| Colors: (\w+) \| Features: ([^\n]+)/i)
    if (headerMatch) {
      console.log(chalk.yellow('Detected Configuration:'))
      console.log(`   Theme: ${headerMatch[1]}`)
      console.log(`   Colors: ${headerMatch[2]}`) 
      console.log(`   Features: ${headerMatch[3]}\n`)
    }
    
    // Extract generation info if available
    const generationMatch = script.match(/# Generated by cc-statusline.*\n# Custom Claude Code statusline - Created: ([^\n]+)/i)
    if (generationMatch) {
      console.log(chalk.gray(`Generated: ${generationMatch[1]}\n`))
    }
    
  } catch (error) {
    console.error(chalk.red(`‚ùå Failed to load script: ${error instanceof Error ? error.message : String(error)}`))
    return
  }
  
  // Test the script
  const testSpinner = ora('Testing statusline with mock data...').start()
  const mockInput = generateMockClaudeInput()
  
  console.log(chalk.gray('\nMock Claude Code Input:'))
  console.log(chalk.gray(JSON.stringify(mockInput, null, 2)))
  
  const testResult = await testStatuslineScript(script, mockInput)
  
  if (testResult.success) {
    testSpinner.succeed(`Test completed in ${testResult.executionTime}ms`)
    
    console.log(chalk.green('\n‚úÖ Statusline Output:'))
    console.log(chalk.white('‚îÅ'.repeat(60)))
    console.log(testResult.output)
    console.log(chalk.white('‚îÅ'.repeat(60)))
    
    // Enhanced performance analysis with platform detection
    console.log(chalk.cyan(`\nüìä Performance: ${getPerformanceEmoji(getPerformanceLevel(testResult.executionTime))} ${getPerformanceLevel(testResult.executionTime)} (${testResult.executionTime}ms)`))
    
    // Platform-specific performance indicators
    const platformInfo = detectPlatformFromOutput(testResult.output)
    if (platformInfo) {
      console.log(chalk.gray(`üñ•Ô∏è  Platform: ${platformInfo.platform} ${platformInfo.version || ''}`))
      
      // Platform-specific performance suggestions
      const suggestions = getPlatformSuggestions(platformInfo.platform, testResult.executionTime)
      if (suggestions.length > 0) {
        console.log(chalk.yellow(`üí° Platform optimizations:`))
        suggestions.forEach(suggestion => {
          console.log(chalk.yellow(`   ‚Ä¢ ${suggestion}`))
        })
      }
    }
    
    // Enhanced system monitoring validation with Phase 3 features
    const systemFeatures = ['üíª', 'üß†', '‚ö°', 'cpu:', 'ram:', 'load:', 'sys:']
    const hasSystemMonitoring = systemFeatures.some(feature => testResult.output.includes(feature))
    
    if (hasSystemMonitoring) {
      console.log(chalk.green('‚úÖ System monitoring features are working'))
      
      // Validate Phase 3 Display Intelligence features
      const trendIndicators = ['‚Üó', '‚Üò', '‚Üí']
      const statusIndicators = ['‚úì', '‚ö†', '‚ùå']
      const hasTrends = trendIndicators.some(indicator => testResult.output.includes(indicator))
      const hasStatus = statusIndicators.some(indicator => testResult.output.includes(indicator))
      
      if (hasTrends) {
        console.log(chalk.green('‚úÖ Load trend indicators detected'))
      }
      
      if (hasStatus) {
        console.log(chalk.green('‚úÖ System status indicators detected'))
      }
      
      // Check for smart formatting patterns
      const smartFormats = [
        /\d+M\/\d+M/,  // MB format
        /\d+\.\d+G\/\d+\.\d+G/,  // GB with decimals
        /\d+G\/\d+G/,  // GB integer format
        /\d+c:/  // CPU cores context
      ]
      const hasSmartFormatting = smartFormats.some(pattern => pattern.test(testResult.output))
      
      if (hasSmartFormatting) {
        console.log(chalk.green('‚úÖ Smart formatting detected'))
      }
      
      // Check for ultra-compact mode (multiple metrics in one line)
      if (testResult.output.includes('sys:') || (testResult.output.includes('üíª') && testResult.output.includes('üß†') && testResult.output.includes('‚ö°'))) {
        console.log(chalk.green('‚úÖ Enhanced compact mode detected'))
      }
      
      // Performance timing breakdown if debug info is available
      if (testResult.output.includes('Collection time:')) {
        const timingMatch = testResult.output.match(/Collection time: (\d+)ms/)
        if (timingMatch) {
          const collectionTime = parseInt(timingMatch[1])
          console.log(chalk.cyan(`‚è±Ô∏è  System metrics collection: ${collectionTime}ms`))
          
          if (collectionTime > 100) {
            console.log(chalk.yellow('   ‚ö†Ô∏è  System monitoring overhead is high'))
          } else if (collectionTime < 50) {
            console.log(chalk.green('   ‚úÖ System monitoring is highly optimized'))
          }
        }
      }
      
      // Validate configurable thresholds are working
      if (testResult.output.includes('# Red at') || testResult.output.includes('# Yellow at')) {
        console.log(chalk.green('‚úÖ Configurable thresholds are active'))
      }
    }
    
    // Basic output validation
    if (testResult.output.includes('üìÅ') || testResult.output.includes('üåø') || testResult.output.includes('ü§ñ')) {
      console.log(chalk.green('‚úÖ Basic statusline features appear to be working'))
    } else {
      console.log(chalk.yellow('‚ö†Ô∏è  Basic features may not be displaying correctly'))
    }
    
  } else {
    testSpinner.fail('Test failed')
    console.error(chalk.red(`\n‚ùå Error: ${testResult.error}`))
    if (testResult.output) {
      console.log(chalk.gray('\nPartial output:'))
      console.log(testResult.output)
    }
  }
  
  console.log(chalk.green('\n‚ú® Preview complete! Use `cc-statusline init` to generate a new statusline.'))
}

function getPerformanceEmoji(performance: string): string {
  switch (performance) {
    case 'excellent': return 'üöÄ'
    case 'good': return '‚úÖ'
    case 'slow': return '‚ö†Ô∏è'
    case 'timeout': return 'üêå'
    default: return '‚ùì'
  }
}

function getPerformanceLevel(executionTime: number): string {
  if (executionTime > 1000) return 'timeout'
  if (executionTime > 500) return 'slow'
  if (executionTime > 100) return 'good'
  return 'excellent'
}

function detectPlatformFromOutput(output: string): { platform: string, version?: string } | null {
  if (output.includes('WSL')) {
    const versionMatch = output.match(/WSL(\d+)/)
    return { platform: 'WSL', version: versionMatch ? `v${versionMatch[1]}` : undefined }
  }
  
  if (output.includes('Darwin')) {
    return { platform: 'macOS' }
  }
  
  if (output.includes('Linux')) {
    return { platform: 'Linux' }
  }
  
  if (output.includes('Microsoft') || output.includes('microsoft')) {
    return { platform: 'WSL' }
  }
  
  return null
}

function getPlatformSuggestions(platform: string, executionTime: number): string[] {
  const suggestions: string[] = []
  
  switch (platform) {
    case 'WSL':
      if (executionTime > 200) {
        suggestions.push('WSL detected - performance optimizations are active')
        suggestions.push('Consider upgrading to WSL2 for better performance')
      }
      if (executionTime > 300) {
        suggestions.push('Enable WSL-specific /proc filesystem optimizations')
      }
      break
      
    case 'macOS':
      if (executionTime > 250) {
        suggestions.push('Ensure sysctl and vm_stat commands are available')
        suggestions.push('Dynamic page size detection is enabled')
      }
      if (executionTime > 400) {
        suggestions.push('Consider using brew to install missing system tools')
      }
      break
      
    case 'Linux':
      if (executionTime > 200) {
        suggestions.push('Enhanced /proc filesystem optimizations are active')
        suggestions.push('Consider reducing system monitoring refresh rate')
      }
      if (executionTime > 350) {
        suggestions.push('Verify vmstat and /proc filesystem access')
      }
      break
  }
  
  return suggestions
}